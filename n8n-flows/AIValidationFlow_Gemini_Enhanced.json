{
  "name": "AI Validation Flow - Enhanced (Individual + Session Context)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ai-validation-enhanced",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-start",
      "name": "Webhook - Start Validation",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        240,
        400
      ],
      "webhookId": "ai-validation-enhanced-webhook"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ {\"success\": true, \"validation_detail_id\": $json.body.validation_detail_id, \"message\": \"Validation started\"} }}"
      },
      "id": "respond-success",
      "name": "Respond Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        460,
        400
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE validation_detail SET validation_status = 'processing', updated_at = NOW() WHERE id = {{ $json.body.validation_detail_id }}"
      },
      "id": "update-status-processing",
      "name": "Update Status: Processing",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        680,
        400
      ],
      "credentials": {
        "supabaseApi": {
          "id": "YOUR_SUPABASE_CREDENTIALS_ID",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "tableId": "validation_detail",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $json.body.validation_detail_id }}"
            }
          ]
        },
        "options": {
          "queryName": "validation_summary(id, unit_code, unitLink, rto_code, created_at)"
        }
      },
      "id": "fetch-validation-context",
      "name": "Fetch Validation Context",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        900,
        400
      ],
      "credentials": {
        "supabaseApi": {
          "id": "YOUR_SUPABASE_CREDENTIALS_ID",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "tableId": "documents",
        "returnAll": true,
        "filters": {
          "conditions": [
            {
              "keyName": "validation_detail_id",
              "condition": "eq",
              "keyValue": "={{ $json.body.validation_detail_id }}"
            },
            {
              "keyName": "gemini_file_uri",
              "condition": "isNotEmpty"
            }
          ]
        }
      },
      "id": "fetch-documents",
      "name": "Fetch Documents with Metadata",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1120,
        400
      ],
      "credentials": {
        "supabaseApi": {
          "id": "YOUR_SUPABASE_CREDENTIALS_ID",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SUPABASE_URL }}/functions/v1/get-requirements",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\"unit_code\": $('Fetch Validation Context').item.json.validation_summary.unit_code, \"validation_detail_id\": $('Fetch Validation Context').item.json.id} }}",
        "options": {}
      },
      "id": "fetch-requirements",
      "name": "Fetch Requirements (Edge Function)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1340,
        400
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "YOUR_SUPABASE_AUTH_CREDENTIALS_ID",
          "name": "Supabase Authorization Header"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Split requirements into individual items for individual validation\nconst response = $input.first().json;\nconst validationContext = $('Fetch Validation Context').first().json;\nconst documents = $('Fetch Documents with Metadata').all().map(item => item.json);\n\nif (!response.success || !response.requirements_by_type) {\n  throw new Error('Failed to fetch requirements from edge function');\n}\n\nconst requirementsByType = response.requirements_by_type;\nconst allRequirements = [];\n\n// Flatten all requirements with type information\nfor (const [type, items] of Object.entries(requirementsByType)) {\n  if (items && items.length > 0) {\n    items.forEach((req, index) => {\n      allRequirements.push({\n        ...req,\n        requirement_type: type,\n        requirement_index: index,\n        validation_detail_id: validationContext.id,\n        unit_code: validationContext.validation_summary.unit_code,\n        rto_code: validationContext.validation_summary.rto_code,\n        session_created_at: validationContext.created_at,\n        session_id: validationContext.id,\n        document_count: documents.length,\n        document_metadata: documents.map(d => ({\n          file_name: d.file_name,\n          document_type: d.document_type,\n          created_at: d.created_at,\n          gemini_file_uri: d.gemini_file_uri\n        }))\n      });\n    });\n  }\n}\n\nconsole.log(`Split into ${allRequirements.length} individual requirements`);\nreturn allRequirements.map((req, idx) => ({\n  json: {\n    ...req,\n    total_requirements: allRequirements.length,\n    current_index: idx + 1\n  }\n}));"
      },
      "id": "split-requirements",
      "name": "Split into Individual Requirements",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1560,
        400
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE validation_detail SET validation_total = {{ $json.total_requirements }}, updated_at = NOW() WHERE id = {{ $json.validation_detail_id }}"
      },
      "id": "update-total",
      "name": "Update Total Requirements",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1780,
        400
      ],
      "credentials": {
        "supabaseApi": {
          "id": "YOUR_SUPABASE_CREDENTIALS_ID",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT prompt_text, system_instruction, output_schema, generation_config FROM prompts WHERE prompt_type = 'validation' AND requirement_type = '{{ $json.requirement_type }}' AND is_active = true AND is_default = true LIMIT 1"
      },
      "id": "fetch-prompt",
      "name": "Fetch Prompt Template",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2000,
        400
      ],
      "credentials": {
        "supabaseApi": {
          "id": "YOUR_SUPABASE_CREDENTIALS_ID",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Prepare Gemini request with FULL session context\nconst requirement = $json;\nconst promptData = $input.first().json;\nconst documents = requirement.document_metadata;\n\n// Build session context (from original workflow)\nconst sessionContext = `\n**VALIDATION SESSION CONTEXT**\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\nSession ID: ${requirement.session_id}\nSession Created: ${new Date(requirement.session_created_at).toLocaleString()}\nUnit Code: ${requirement.unit_code}\nRTO Code: ${requirement.rto_code}\nRequirement Type: ${requirement.requirement_type}\nRequirement ${requirement.current_index} of ${requirement.total_requirements}\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n**DOCUMENTS FOR THIS SESSION** (${documents.length} files):\n${documents.map((d, i) => `${i + 1}. ${d.file_name} (${d.document_type || 'Assessment Document'})\n   - Uploaded: ${new Date(d.created_at).toLocaleString()}\n   - Gemini URI: ${d.gemini_file_uri}`).join('\\n')}\n\n**IMPORTANT INSTRUCTIONS**:\n1. This is an ISOLATED validation session\n2. Only consider documents uploaded for THIS session (${new Date(requirement.session_created_at).toLocaleString()})\n3. All citations must reference documents from THIS session only\n4. Include document names and page numbers in all evidence citations\n5. Understand images, charts, and diagrams in the documents\n6. This is requirement ${requirement.current_index} of ${requirement.total_requirements}\n\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n`;\n\n// Replace variables in prompt template\nlet promptText = promptData.prompt_text || 'Validate the following requirement against the provided documents.';\npromptText = promptText\n  .replace(/{{requirement_number}}/g, requirement.requirement_number || '')\n  .replace(/{{requirement_text}}/g, requirement.requirement_text || '')\n  .replace(/{{requirement_type}}/g, requirement.requirement_type || '')\n  .replace(/{{unit_code}}/g, requirement.unit_code || '')\n  .replace(/{{document_type}}/g, requirement.document_type || 'unit');\n\n// Build file parts\nconst fileParts = documents.map(doc => ({\n  fileData: {\n    mimeType: \"application/pdf\",\n    fileUri: doc.gemini_file_uri\n  }\n}));\n\n// Build complete prompt with session context\nconst fullPrompt = `${sessionContext}\\n\\n${promptText}`;\n\n// Build Gemini request\nconst geminiRequest = {\n  systemInstruction: {\n    parts: [{text: promptData.system_instruction || 'You are an expert RTO validator.'}]\n  },\n  contents: [\n    ...fileParts.map(file => ({parts: [file]})),\n    {parts: [{text: fullPrompt}]}\n  ],\n  generationConfig: {\n    ...(promptData.generation_config || {}),\n    temperature: 0.1,\n    maxOutputTokens: 8192,\n    responseMimeType: \"application/json\",\n    responseSchema: promptData.output_schema || {}\n  }\n};\n\nreturn {\n  json: {\n    ...requirement,\n    gemini_request: geminiRequest,\n    prompt_used: fullPrompt,\n    session_context: sessionContext\n  }\n};"
      },
      "id": "prepare-request",
      "name": "Prepare Request with Session Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2220,
        400
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Rate limiting based on tier\nconst tier = $env.GEMINI_TIER || 'free';\nconst rpm = tier === 'paid' ? 1000 : 15;\nconst delayMs = Math.ceil((60 / rpm) * 1000);\n\nconsole.log(`Rate limiting: ${tier} tier, ${rpm} RPM, ${delayMs}ms delay`);\nawait new Promise(resolve => setTimeout(resolve, delayMs));\n\nreturn $input.all();"
      },
      "id": "rate-limit",
      "name": "Rate Limit Delay",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2440,
        400
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googlePalmApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.gemini_request }}",
        "options": {
          "retry": {
            "retry": {
              "maxRetries": 3,
              "retryOnStatusCodes": "429,500,502,503,504"
            }
          },
          "timeout": 120000
        }
      },
      "id": "call-gemini",
      "name": "Call Gemini API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2660,
        400
      ],
      "credentials": {
        "googlePalmApi": {
          "id": "YOUR_GOOGLE_GEMINI_CREDENTIALS_ID",
          "name": "Google Gemini API"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Parse Gemini response with session context and rich metadata\nconst response = $json;\nconst requirement = $('Prepare Request with Session Context').item.json;\nconst sessionContext = requirement.session_context;\nconst documentNames = requirement.document_metadata.map(d => d.file_name);\n\n// Extract text from Gemini response\nlet responseText = '';\nif (response.candidates && response.candidates[0]?.content?.parts?.[0]?.text) {\n  responseText = response.candidates[0].content.parts[0].text;\n}\n\n// Parse JSON response\nlet validationResult;\ntry {\n  responseText = responseText.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n  validationResult = JSON.parse(responseText);\n} catch (error) {\n  console.error('Failed to parse AI response:', error);\n  validationResult = {\n    status: \"error\",\n    reasoning: \"Failed to parse AI response: \" + error.message,\n    error: true\n  };\n}\n\n// Transform to database format with RICH metadata (from original workflow)\nreturn {\n  json: {\n    validation_detail_id: requirement.validation_detail_id,\n    requirement_type: requirement.requirement_type,\n    requirement_number: requirement.requirement_number || validationResult.requirementNumber,\n    requirement_text: requirement.requirement_text || validationResult.requirementText,\n    status: validationResult.status,\n    reasoning: validationResult.reasoning,\n    mapped_content: validationResult.mapped_content || null,\n    unmapped_content: validationResult.unmapped_content || null,\n    recommendations: validationResult.recommendations || null,\n    citations: JSON.stringify((validationResult.evidenceFound || validationResult.doc_references || []).map(evidence => ({\n      document_name: evidence.document || evidence.document_name || 'Unknown',\n      location: evidence.location || evidence.page || 'Unknown',\n      content: evidence.content || evidence.excerpt || '',\n      relevance: evidence.relevance || evidence.explanation || ''\n    }))),\n    smart_questions: JSON.stringify(validationResult.smartQuestions || validationResult.smart_questions || []),\n    metadata: JSON.stringify({\n      gaps: validationResult.gaps || [],\n      confidence_score: validationResult.confidence_score || null,\n      documents_analyzed: documentNames,\n      validated_at: new Date().toISOString(),\n      validation_method: 'gemini_file_api_enhanced',\n      session_context: {\n        session_id: requirement.session_id,\n        session_created_at: requirement.session_created_at,\n        unit_code: requirement.unit_code,\n        rto_code: requirement.rto_code,\n        requirement_index: requirement.current_index,\n        total_requirements: requirement.total_requirements\n      },\n      prompt_used: requirement.prompt_used\n    })\n  }\n};"
      },
      "id": "parse-response",
      "name": "Parse Response with Rich Metadata",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2880,
        400
      ]
    },
    {
      "parameters": {
        "operation": "insert",
        "tableId": "validation_results",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "validation_detail_id",
              "fieldValue": "={{ $json.validation_detail_id }}"
            },
            {
              "fieldId": "requirement_type",
              "fieldValue": "={{ $json.requirement_type }}"
            },
            {
              "fieldId": "requirement_number",
              "fieldValue": "={{ $json.requirement_number }}"
            },
            {
              "fieldId": "requirement_text",
              "fieldValue": "={{ $json.requirement_text }}"
            },
            {
              "fieldId": "status",
              "fieldValue": "={{ $json.status }}"
            },
            {
              "fieldId": "reasoning",
              "fieldValue": "={{ $json.reasoning }}"
            },
            {
              "fieldId": "mapped_content",
              "fieldValue": "={{ $json.mapped_content }}"
            },
            {
              "fieldId": "unmapped_content",
              "fieldValue": "={{ $json.unmapped_content }}"
            },
            {
              "fieldId": "recommendations",
              "fieldValue": "={{ $json.recommendations }}"
            },
            {
              "fieldId": "citations",
              "fieldValue": "={{ $json.citations }}"
            },
            {
              "fieldId": "smart_questions",
              "fieldValue": "={{ $json.smart_questions }}"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ $json.metadata }}"
            }
          ]
        }
      },
      "id": "save-result",
      "name": "Save Validation Result",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        3100,
        400
      ],
      "credentials": {
        "supabaseApi": {
          "id": "YOUR_SUPABASE_CREDENTIALS_ID",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE validation_detail SET validation_count = validation_count + 1, validation_progress = ROUND((validation_count + 1)::numeric / validation_total * 100, 2), updated_at = NOW() WHERE id = {{ $json.validation_detail_id }}"
      },
      "id": "update-progress",
      "name": "Update Progress",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        3320,
        400
      ],
      "credentials": {
        "supabaseApi": {
          "id": "YOUR_SUPABASE_CREDENTIALS_ID",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "operation": "aggregateItems",
        "aggregate": "aggregateAllItemData",
        "destinationFieldName": "all_results",
        "options": {}
      },
      "id": "aggregate-results",
      "name": "Aggregate Results",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        3540,
        400
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE validation_detail SET validation_status = 'completed', validation_progress = 100, updated_at = NOW() WHERE id = {{ $json.all_results[0].validation_detail_id }}"
      },
      "id": "update-status-completed",
      "name": "Update Status: Completed",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        3760,
        400
      ],
      "credentials": {
        "supabaseApi": {
          "id": "YOUR_SUPABASE_CREDENTIALS_ID",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE validation_detail SET validation_status = 'failed', error_message = '{{ $json.error.message }}', updated_at = NOW() WHERE id = {{ $json.validation_detail_id }}"
      },
      "id": "update-status-error",
      "name": "Update Status: Error",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2880,
        600
      ],
      "credentials": {
        "supabaseApi": {
          "id": "YOUR_SUPABASE_CREDENTIALS_ID",
          "name": "Supabase account"
        }
      }
    }
  ],
  "connections": {
    "Webhook - Start Validation": {
      "main": [
        [
          {
            "node": "Respond Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Respond Success": {
      "main": [
        [
          {
            "node": "Update Status: Processing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Status: Processing": {
      "main": [
        [
          {
            "node": "Fetch Validation Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Validation Context": {
      "main": [
        [
          {
            "node": "Fetch Documents with Metadata",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Documents with Metadata": {
      "main": [
        [
          {
            "node": "Fetch Requirements (Edge Function)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Requirements (Edge Function)": {
      "main": [
        [
          {
            "node": "Split into Individual Requirements",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split into Individual Requirements": {
      "main": [
        [
          {
            "node": "Update Total Requirements",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Total Requirements": {
      "main": [
        [
          {
            "node": "Fetch Prompt Template",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Prompt Template": {
      "main": [
        [
          {
            "node": "Prepare Request with Session Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Request with Session Context": {
      "main": [
        [
          {
            "node": "Rate Limit Delay",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rate Limit Delay": {
      "main": [
        [
          {
            "node": "Call Gemini API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Gemini API": {
      "main": [
        [
          {
            "node": "Parse Response with Rich Metadata",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Status: Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Response with Rich Metadata": {
      "main": [
        [
          {
            "node": "Save Validation Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Validation Result": {
      "main": [
        [
          {
            "node": "Update Progress",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Progress": {
      "main": [
        [
          {
            "node": "Aggregate Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Results": {
      "main": [
        [
          {
            "node": "Update Status: Completed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2025-01-29T00:00:00.000Z",
  "versionId": "1"
}