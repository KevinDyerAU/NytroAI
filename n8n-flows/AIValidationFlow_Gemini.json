{
  "name": "AIValidationFlow_Gemini",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "validation-processing-gemini",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook - Start Validation",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 400],
      "webhookId": "validation-processing-gemini-webhook"
    },
    {
      "parameters": {
        "operation": "get",
        "tableId": "validation_detail",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $json.body.validation_detail_id }}"
            }
          ]
        },
        "options": {
          "queryName": "validation_summary(unit_code, unitLink, rto_code)"
        }
      },
      "id": "fetch-validation-context",
      "name": "Fetch Validation Context",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [460, 400],
      "credentials": {
        "supabaseApi": {
          "id": "YOUR_SUPABASE_CREDENTIALS_ID",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "tableId": "documents",
        "returnAll": true,
        "filters": {
          "conditions": [
            {
              "keyName": "validation_detail_id",
              "condition": "eq",
              "keyValue": "={{ $json.body.validation_detail_id }}"
            },
            {
              "keyName": "gemini_file_uri",
              "condition": "isNotEmpty"
            }
          ]
        }
      },
      "id": "fetch-gemini-files",
      "name": "Fetch Gemini File URIs",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [680, 400],
      "credentials": {
        "supabaseApi": {
          "id": "YOUR_SUPABASE_CREDENTIALS_ID",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "tableId": "prompt",
        "filters": {
          "conditions": [
            {
              "keyName": "current",
              "condition": "eq",
              "keyValue": "true"
            }
          ]
        }
      },
      "id": "fetch-system-prompt",
      "name": "Fetch System Prompt",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [900, 400],
      "credentials": {
        "supabaseApi": {
          "id": "YOUR_SUPABASE_CREDENTIALS_ID",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ $('Fetch Validation Context').item.json.validation_summary.unitLink }}",
        "options": {}
      },
      "id": "fetch-unit-requirements",
      "name": "Fetch Unit Requirements",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1120, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Parse unit requirements and group by type\nconst unitData = $input.first().json;\n\n// Extract requirements from different sections\nconst requirements = {\n  knowledge_evidence: unitData.knowledgeEvidence || [],\n  performance_evidence: unitData.performanceEvidence || [],\n  foundation_skills: unitData.foundationSkills || [],\n  elements_performance_criteria: unitData.elementsAndPerformanceCriteria || [],\n  assessment_conditions: unitData.assessmentConditions || []\n};\n\n// Group by type for batch processing\nconst requirementGroups = [];\n\nfor (const [type, items] of Object.entries(requirements)) {\n  if (items && items.length > 0) {\n    requirementGroups.push({\n      validation_type: type,\n      requirements: items,\n      requirements_json: JSON.stringify(items)\n    });\n  }\n}\n\nreturn requirementGroups.map(group => ({ json: group }));"
      },
      "id": "group-requirements",
      "name": "Group Requirements by Type",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Prepare Gemini API request with file references\nconst validationType = $json.validation_type;\nconst requirementsJSON = $json.requirements_json;\nconst systemPrompt = $('Fetch System Prompt').first().json.prompt || 'You are an expert RTO validator.';\nconst unitCode = $('Fetch Validation Context').first().json.validation_summary.unit_code;\nconst documents = $('Fetch Gemini File URIs').all().map(item => item.json);\n\n// Build file parts for Gemini\nconst fileParts = documents.map(doc => ({\n  fileData: {\n    mimeType: \"application/pdf\",\n    fileUri: doc.gemini_file_uri\n  }\n}));\n\n// Build prompt\nconst promptText = `${systemPrompt}\n\n**Unit of Competency**: ${unitCode}\n\n**Validation Type**: ${validationType}\n\n**Documents Available** (${documents.length} files):\n${documents.map(d => `- ${d.file_name} (${d.document_type || 'Assessment Document'})`).join('\\n')}\n\n**Requirements** (JSON Array):\n\\`\\`\\`json\n${requirementsJSON}\n\\`\\`\\`\n\n**MULTI-DOCUMENT INSTRUCTIONS**:\nYou have access to ${documents.length} assessment documents.\nWhen citing evidence:\n1. ALWAYS reference the specific document name\n2. Include page numbers from that document\n3. Format: \"Document: [name], Page: [number]\"\n4. Consider evidence across ALL documents\n5. Understand images, charts, and diagrams in the documents\n\nExample: \"Assessment Task (Page 3, Question 5) supported by Marking Guide (Page 2)\"\n\n**Task**: Validate each requirement in the JSON array against ALL assessment documents. Return results in JSON format with the following structure:\n\n\\`\\`\\`json\n{\n  \"validationType\": \"${validationType}\",\n  \"unitCode\": \"${unitCode}\",\n  \"overallStatus\": \"met\" | \"partial\" | \"not_met\",\n  \"summary\": \"Brief overall summary\",\n  \"requirementValidations\": [\n    {\n      \"requirementId\": <id from JSON>,\n      \"requirementNumber\": \"<number from JSON>\",\n      \"requirementText\": \"<text from JSON>\",\n      \"status\": \"met\" | \"partial\" | \"not_met\",\n      \"reasoning\": \"Detailed explanation with document and page references\",\n      \"evidenceFound\": [\n        {\n          \"document\": \"Document name\",\n          \"location\": \"Page X, Section Y\",\n          \"content\": \"Relevant content excerpt\",\n          \"relevance\": \"How this addresses the requirement\"\n        }\n      ],\n      \"gaps\": [\"Gap 1\", \"Gap 2\"],\n      \"smartQuestions\": [\n        {\n          \"question\": \"Proposed assessment question\",\n          \"rationale\": \"Why this addresses the gap\"\n        }\n      ]\n    }\n  ]\n}\n\\`\\`\\`\n\nIMPORTANT: Return ONLY valid JSON, no additional text.`;\n\n// Build Gemini API request body\nconst contents = [\n  ...fileParts,\n  { text: promptText }\n];\n\nreturn {\n  json: {\n    contents: contents,\n    validation_type: validationType,\n    requirements: $json.requirements,\n    document_count: documents.length,\n    document_names: documents.map(d => d.file_name)\n  }\n};"
      },
      "id": "prepare-gemini-request",
      "name": "Prepare Gemini Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1560, 400]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googlePalmApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"contents\": $json.contents.map(part => ({\n    \"parts\": part.fileData ? [{ \"fileData\": part.fileData }] : [{ \"text\": part.text }]\n  })),\n  \"generationConfig\": {\n    \"temperature\": 0.1,\n    \"maxOutputTokens\": 8192,\n    \"responseMimeType\": \"application/json\"\n  }\n} }}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "call-gemini-api",
      "name": "Call Gemini API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1780, 400],
      "credentials": {
        "googlePalmApi": {
          "id": "YOUR_GOOGLE_GEMINI_CREDENTIALS_ID",
          "name": "Google Gemini API"
        }
      },
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 5000
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Parse Gemini response\nconst response = $json;\nconst validationDetailId = $('Fetch Validation Context').first().json.id;\nconst documentNames = $('Prepare Gemini Request').item.json.document_names;\n\n// Extract text from Gemini response\nlet responseText = '';\nif (response.candidates && response.candidates[0]?.content?.parts?.[0]?.text) {\n  responseText = response.candidates[0].content.parts[0].text;\n}\n\n// Parse JSON response\nlet validationResult;\ntry {\n  // Remove markdown code blocks if present\n  responseText = responseText.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n  validationResult = JSON.parse(responseText);\n} catch (error) {\n  console.error('Failed to parse AI response:', error);\n  return {\n    json: {\n      error: 'Failed to parse AI response',\n      raw_response: responseText,\n      validation_detail_id: validationDetailId\n    }\n  };\n}\n\n// Transform to database format with enhanced citations\nconst validationRecords = validationResult.requirementValidations.map(rv => ({\n  validation_detail_id: validationDetailId,\n  requirement_type: validationResult.validationType,\n  requirement_number: rv.requirementNumber,\n  requirement_text: rv.requirementText,\n  status: rv.status,\n  reasoning: rv.reasoning,\n  citations: JSON.stringify((rv.evidenceFound || []).map(evidence => ({\n    document_name: evidence.document || 'Unknown',\n    location: evidence.location,\n    content: evidence.content,\n    relevance: evidence.relevance\n  }))),\n  smart_questions: JSON.stringify(rv.smartQuestions || []),\n  metadata: JSON.stringify({\n    gaps: rv.gaps || [],\n    overall_status: validationResult.overallStatus,\n    summary: validationResult.summary,\n    documents_analyzed: documentNames,\n    validated_at: new Date().toISOString(),\n    validation_method: 'gemini_file_api'\n  })\n}));\n\nreturn validationRecords.map(record => ({ json: record }));"
      },
      "id": "parse-gemini-response",
      "name": "Parse Gemini Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 400]
    },
    {
      "parameters": {
        "operation": "insert",
        "tableId": "validation_results",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "validation_detail_id",
              "fieldValue": "={{ $json.validation_detail_id }}"
            },
            {
              "fieldId": "requirement_type",
              "fieldValue": "={{ $json.requirement_type }}"
            },
            {
              "fieldId": "requirement_number",
              "fieldValue": "={{ $json.requirement_number }}"
            },
            {
              "fieldId": "requirement_text",
              "fieldValue": "={{ $json.requirement_text }}"
            },
            {
              "fieldId": "status",
              "fieldValue": "={{ $json.status }}"
            },
            {
              "fieldId": "reasoning",
              "fieldValue": "={{ $json.reasoning }}"
            },
            {
              "fieldId": "citations",
              "fieldValue": "={{ $json.citations }}"
            },
            {
              "fieldId": "smart_questions",
              "fieldValue": "={{ $json.smart_questions }}"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ $json.metadata }}"
            }
          ]
        }
      },
      "id": "store-validation-results",
      "name": "Store Validation Results",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [2220, 400],
      "credentials": {
        "supabaseApi": {
          "id": "YOUR_SUPABASE_CREDENTIALS_ID",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Aggregate all validation results\nconst allResults = $input.all();\nconst validationDetailId = $('Fetch Validation Context').first().json.id;\n\nreturn {\n  json: {\n    validation_detail_id: validationDetailId,\n    total_results: allResults.length,\n    success: true\n  }\n};"
      },
      "id": "aggregate-validation-results",
      "name": "Aggregate Validation Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2440, 400]
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "validation_detail",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $json.validation_detail_id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "status",
              "fieldValue": "completed"
            },
            {
              "fieldId": "validationStatus",
              "fieldValue": "Finalised"
            }
          ]
        }
      },
      "id": "update-status-finalised",
      "name": "Update Status: Finalised",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [2660, 400],
      "credentials": {
        "supabaseApi": {
          "id": "YOUR_SUPABASE_CREDENTIALS_ID",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"success\": true, \"validation_detail_id\": $json.validation_detail_id, \"total_results\": $json.total_results, \"message\": \"Validation completed successfully\" } }}"
      },
      "id": "respond-success",
      "name": "Respond Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2880, 400]
    }
  ],
  "connections": {
    "Webhook - Start Validation": {
      "main": [[{"node": "Fetch Validation Context", "type": "main", "index": 0}]]
    },
    "Fetch Validation Context": {
      "main": [[{"node": "Fetch Gemini File URIs", "type": "main", "index": 0}]]
    },
    "Fetch Gemini File URIs": {
      "main": [[{"node": "Fetch System Prompt", "type": "main", "index": 0}]]
    },
    "Fetch System Prompt": {
      "main": [[{"node": "Fetch Unit Requirements", "type": "main", "index": 0}]]
    },
    "Fetch Unit Requirements": {
      "main": [[{"node": "Group Requirements by Type", "type": "main", "index": 0}]]
    },
    "Group Requirements by Type": {
      "main": [[{"node": "Prepare Gemini Request", "type": "main", "index": 0}]]
    },
    "Prepare Gemini Request": {
      "main": [[{"node": "Call Gemini API", "type": "main", "index": 0}]]
    },
    "Call Gemini API": {
      "main": [[{"node": "Parse Gemini Response", "type": "main", "index": 0}]]
    },
    "Parse Gemini Response": {
      "main": [[{"node": "Store Validation Results", "type": "main", "index": 0}]]
    },
    "Store Validation Results": {
      "main": [[{"node": "Aggregate Validation Results", "type": "main", "index": 0}]]
    },
    "Aggregate Validation Results": {
      "main": [[{"node": "Update Status: Finalised", "type": "main", "index": 0}]]
    },
    "Update Status: Finalised": {
      "main": [[{"node": "Respond Success", "type": "main", "index": 0}]]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2025-01-28T00:00:00.000Z",
  "versionId": "1"
}
